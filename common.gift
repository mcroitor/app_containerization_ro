// # Intrebari la tema "Notiuni de bază ale containerizării"
$CATEGORY: examen/1_knowledge/03_definitions

::03k001:: [markdown] Fișierul care conține tot ce este necesar pentru a rula o aplicație (aplicația în sine, bibliotecile dinamice necesare pentru a rula aplicația, fișierele de configurare, datele) se numește:
{
    =[markdown] imagine
    ~[markdown] container
    ~[markdown] serviciu
    ~[markdown] aplicație
}

::03k002:: [markdown] Exemplarul imaginii care rulează în memoria RAM se numește:
{
    =[markdown] container
    ~[markdown] imagine
    ~[markdown] serviciu
    ~[markdown] aplicație
}

::03k003:: [markdown] Programul care rulează de obicei pe un server și oferă servicii specializate clienților se numește:
{
    =[markdown] serviciu
    ~[markdown] imagine
    ~[markdown] container
    ~[markdown] aplicație
}

::03k004:: [markdown] Aplicatia care ofera servicii prin protocolul HTTP se numeste:
{
    =[markdown] Web serviciu
    ~[markdown] server
    ~[markdown] cluster
    ~[markdown] container
}

::03k005:: [markdown] Un server de stocare a unor fișiere (de exemplu, imagini, pachete) se numește:
{
    =[markdown] repozitoriu
    ~[markdown] cluster
    ~[markdown] container
    ~[markdown] serviciu
}

::03k006:: [markdown] Un calculator specializat pe care rulează software-ul serverului se numește:
{
    =[markdown] server
    ~[markdown] client
    ~[markdown] container
    ~[markdown] serviciu
}

::03k007:: [markdown] Grupul de calculatoare pe care rulează aplicația desfășurată în containere se numește:
{
    =[markdown] cluster
    ~[markdown] repozitoriu
    ~[markdown] container
    ~[markdown] serviciu
}

::03k008:: [markdown] Procesul de creștere a performanței unei aplicații prin creșterea resurselor alocate pentru funcționarea sa se numește:
{
    =[markdown] scalare
    ~[markdown] containerizare
    ~[markdown] clusterizare
    ~[markdown] virtualizare
}

::03k009:: [markdown] Creșterea performanței unei aplicații prin creșterea numărului de servere pe care rulează aplicația se numește:
{
    =[markdown] scalare orizontală
    ~[markdown] scalare verticală
    ~[markdown] clusterizare
    ~[markdown] virtualizare
}

::03k010:: [markdown] Creșterea performanței unei aplicații prin creșterea resurselor alocate pentru funcționarea sa se numește:
{
    =[markdown] scalare verticală
    ~[markdown] scalare orizontală
    ~[markdown] clusterizare
    ~[markdown] virtualizare
}

::03k011:: [markdown] Aplicația care oferă servicii specializate clienților se numește:
{
    =[markdown] serviciu
    ~[markdown] container
    ~[markdown] server
    ~[markdown] client
}

::03k012:: [markdown] Proprietate de bază a serverelor este:
{
    =[markdown] fiabilitatea
    ~[markdown] performanța
    ~[markdown] scalabilitatea
    ~[markdown] gestionabilitatea
}

::03k013:: [markdown] Capacitatea serverului de a procesa cererile clienților într-un timp minim se numește:
{
    =[markdown] performanța
    ~[markdown] fiabilitatea
    ~[markdown] scalabilitatea
    ~[markdown] gestionabilitatea
}

::03k014:: [markdown] Capacitatea serverului de a crește performanța prin creșterea resurselor alocate pentru funcționarea sa se numește:
{
    =[markdown] scalabilitatea
    ~[markdown] fiabilitatea
    ~[markdown] performanța
    ~[markdown] gestionabilitatea
}

::03k015:: [markdown] Arhitectura aplicației în care tot codul aplicației se află într-un singur component se numește:
{
    =[markdown] monolitică
    ~[markdown] multicompontentă
    ~[markdown] microservicii
    ~[markdown] modulară
}

::03k016:: [markdown] Arhitectura aplicației, în care codul aplicației este împărțit în module independente, se numește:
{
    =[markdown] multicompontentă
    ~[markdown] monolitică
    ~[markdown] client-server
    ~[markdown] multistrat
}

::03k017:: [markdown] Procesul de gestionare a unui set de containere se numește:
{
    =[markdown] orchestrare
    ~[markdown] virtualizare
    ~[markdown] containerizare
    ~[markdown] clusterizare
}

::03k018:: [markdown] Grupul de calculatoare, care sunt conectate la o rețea comună și care rulează software specializat, care oferă servicii utilizatorilor, se numește:
{
    =[markdown] cloud
    ~[markdown] cluster
    ~[markdown] server
    ~[markdown] container
}

::03k019:: [markdown] Tehnologia care permite rularea unui exemplar al unui sistem de operare în cadrul altui sistem de operare se numește:
{
    =[markdown] virtualizare
    ~[markdown] containerizare
    ~[markdown] orchestrare
    ~[markdown] clusterizare
}

::03k020:: [markdown] Tehnologia care permite rularea unui exemplar al unei aplicații într-un mediu izolat se numește:
{
    =[markdown] containerizare
    ~[markdown] virtualizare
    ~[markdown] orchestrare
    ~[markdown] clusterizare
}

::03k021:: [markdown] Calculator, care oferă resursele sale (de exemplu, resurse de calcul, rețea, stocare) pentru containere, se numește:
{
    =[markdown] host
    ~[markdown] server
    ~[markdown] client
    ~[markdown] imagine
}

// # Intrebari la tema "Sintaxa Dockerfile"

$CATEGORY: examen/1_knowledge/04_dockerfile_i

::04k001:: [markdown] Ce este contextul de construire?
{
    =[markdown] Este directorul în care se află fișierul `Dockerfile`.
    ~[markdown] Este directorul în care se află fișierul `docker-compose.yml`.
    ~[markdown] Este directorul din care se execută comanda `docker build`.
    ~[markdown] Este imaginea folosită pentru construirea altor imagini.
}

::04k002:: [markdown] Prin care comandă se specifică imaginea de bază?
{
    =[markdown] `FROM`
    ~[markdown] `BASE`
    ~[markdown] `BASE_IMAGE`
    ~[markdown] `BASE_IMAGE_NAME`
}

::04k003:: [markdown] Eticheta text specială care indică, de exemplu, versiunea imaginii sau caracteristicile sale se numește
{
    =[markdown] `tag`
    ~[markdown] `versiune`
    ~[markdown] `metadate`
    ~[markdown] `atribut`
}

::04k004:: [markdown] La specificarea imaginii de bază se poate specifica eticheta care corespunde versiunii specifice a imaginii de bază. Dacă eticheta nu este specificată, atunci va fi utilizată eticheta
{
    =[markdown] `latest`
    ~[markdown] `current`
    ~[markdown] `newest`
    ~[markdown] `recent`
}

::04k005:: [markdown] Dacă imaginea de bază nu este specificată, atunci va fi utilizată imaginea de bază
{
    =[markdown] `scratch`
    ~[markdown] `empty`
    ~[markdown] `none`
    ~[markdown] `null`
}

::04k006:: [markdown] Prin care comandă se specifică metadatele imaginii?
{
    =[markdown] `LABEL`
    ~[markdown] `META`
    ~[markdown] `METADATA`
    ~[markdown] `METAINFO`
}

::04k007:: [markdown] Prin care comandă se specifică argumentele de construire?
{
    =[markdown] `ARG`
    ~[markdown] `ARGUMENT`
    ~[markdown] `BUILD_ARG`
    ~[markdown] `BUILD_ARGUMENT`
}

::04k008:: [markdown] Prin care comandă se specifică punctul de intrare pentru rularea containerului?
{
    =[markdown] `CMD`
    ~[markdown] `EXEC`
    ~[markdown] `RUN`
    ~[markdown] `START`
}

::04k009:: [markdown] Pentru a copia fișiere și directoare din contextul de construire în sistemul de fișiere al imaginii, se folosește comanda
{
    =[markdown] `COPY`
    ~[markdown] `MOVE`
    ~[markdown] `INSERT`
    ~[markdown] `PASTE`
}

::04k010:: [markdown] Imaginea containerului este construită implicit pe baza descrierii fișierului
{
    =[markdown] `Dockerfile`
    ~[markdown] `docker-compose.yaml`
    ~[markdown] `docker-image.def`
    ~[markdown] `image.json`
}

::04k011:: [markdown] Pentru a descărca un arhivă de la o adresă URL și copia în imaginea se folosește comanda
{
    =[markdown] `ADD`
    ~[markdown] `COPY`
    ~[markdown] `GET`
    ~[markdown] `DOWNLOAD`
}

::04k012:: [markdown] Executarea unei anumite comenzi la construirea imaginii containerului este determinată de directiva
{
    =[markdown] `RUN`
    ~[markdown] `EXEC`
    ~[markdown] `CMD`
    ~[markdown] `DO`
}

::04k013:: [markdown] Pentru a specifica directorul de lucru în care se vor executa toate următoarele comenzi, se folosește comanda
{
    =[markdown] `WORKDIR`
    ~[markdown] `WORK`
    ~[markdown] `DIR`
    ~[markdown] `CD`
}

::04k014:: [markdown] Schimbarea utilizatorului în imagine se poate face cu ajutorul comenzii
{
    =[markdown] `USER`
    ~[markdown] `CHANGE_USER`
    ~[markdown] `SWITCH_USER`
    ~[markdown] `CHOWN`
}

::04k015:: [markdown] Pentru copierea fisierului `php-fpm.conf` din directorul `files/configs` în directorul `/etc/php` al imaginii, se folosește comanda
{
    =[markdown] `COPY files/configs/php-fpm.conf /etc/php`
    ~[markdown] `COPY /etc/php files/configs/php-fpm.conf`
    ~[markdown] `COPY /etc/php/php-fpm.conf files/configs`
    ~[markdown] `COPY /files/configs/php-fpm.conf /etc/php`
}

::04k016:: [markdown] Pentru a crea directorul `/var/www` în imagine, se folosește comanda
{
    =[markdown] `RUN mkdir /var/www`
    ~[markdown] `COPY /var/www`
    ~[markdown] `CREATE /var/www`
    ~[markdown] `MKDIR /var/www`
}

::04k017:: [markdown] Pentru a instala pachetul `nginx` în imagine, se folosește comanda
{
    =[markdown] `RUN apt-get install -y nginx`
    ~[markdown] `COPY apt-get install -y nginx`
    ~[markdown] `INSTALL nginx`
    ~[markdown] `ADD apt-get install -y nginx`
}

::04k018:: [markdown] Pentru a executa comanda `nginx -g "daemon off;"` la rularea containerului, se folosește comanda
{
    =[markdown] `CMD ["nginx", "-g", "daemon off;"]`
    ~[markdown] `RUN ["nginx", "-g", "daemon off;"]`
    ~[markdown] `START ["nginx", "-g", "daemon off;"]`
    ~[markdown] `EXEC ["nginx", "-g", "daemon off;"]`
}

::04k019:: [markdown] Reinnoirea listelor de pachete și a pachetelor în imaginea pe baza OS Ubuntu se poate face cu ajutorul comenzii
{
    =[markdown] `RUN apt-get update && apt-get -y upgrade`
    ~[markdown] `RUN apt-get update`
    ~[markdown] `RUN apt-get -y upgrade`
    ~[markdown] `UPGRADE packages`
}

::04k020:: [markdown] Diferența dintre comenzile `CMD` și `ENTRYPOINT` constă în faptul că
{
    =[markdown] `CMD` permite redefinirea comenzii la rularea containerului, iar `ENTRYPOINT` - nu.
    ~[markdown] `ENTRYPOINT` permite redefinirea comenzii la rularea containerului, iar `CMD` - nu.
    ~[markdown] `CMD` și `ENTRYPOINT` efectuează aceleași acțiuni.
    ~[markdown] `CMD` și `ENTRYPOINT` efectuează acțiuni diferite.
}

// # Intrebari la tema "Sintaxa Dockerfile"

// Întrebări de tip _răspuns scurt_:
$CATEGORY: examen/2_usage/04_dockerfile_i

::04u001:: [markdown] În Dockerfile pentru crearea unei imagini pe baza imaginii `ubuntu\:20.04` se folosește comanda {=FROM ubuntu\:20.04}

::04u002:: [markdown] În Dockerfile pentru crearea unei imagini pe baza ultimei imagini create `nginx` se folosește comanda { =FROM nginx =FROM nginx\:latest}

::04u003:: [markdown] În Dockerfile pentru crearea unei imagini pe baza unei imagini goale se folosește comanda { =FROM scratch}

::04u004:: [markdown] Care comandă în Dockerfile se folosește pentru instalarea pachetului `nano` în imaginea pe baza OS Ubuntu? {=RUN apt-get install -y nano =RUN apt-get install nano -y =RUN apt install -y nano =RUN apt install nano -y}

::04u005:: [markdown] În Dockerfile pentru copierea fișierului `php.ini` din directorul `files` contextului de construire în imagine în directorul `/etc/php/7.4/cli` se folosește comanda {=COPY files/php.ini /etc/php/7.4/cli}

::04u006:: [markdown] În Dockerfile pentru crearea directorului `/var/www` în imagine se folosește comanda {=RUN mkdir /var/www}

::04u007:: [markdown] Pentru a schimba utilizatorul în imagine pe `www-data` se folosește comanda {=USER www-data}

::04u008:: [markdown] Pentru a instala pachetul `nginx` în imagine pe baza OS Ubuntu se folosește comanda {=RUN apt-get install -y nginx =RUN apt-get install nginx -y =RUN apt install -y nginx =RUN apt install nginx -y}

::04u009:: [markdown] Pentru a executa comanda `nginx -g "daemon off;"` la rularea containerului, se folosește comanda {=CMD ["nginx", "-g", "daemon off;"] =CMD nginx -g "daemon off;"}

::04u010:: [markdown] Pentru a schimba directorul de lucru în imagine pe `/var/www` se folosește comanda {=WORKDIR /var/www =WORKDIR /var/www/}

// # Întrebări la tema "Rularea aplicațiilor containerizate"

$CATEGORY: examen/1_knowledge/05_docker_run

::05k001:: [markdown] Ce comandă se utilizează pentru construirea imaginii?
{
  =[markdown] `docker image build`
  ~[markdown] `docker create`
  ~[markdown] `docker image run`
  ~[markdown] `docker image start`
}

::05k002:: [markdown] Cu ce comandă se poate vizualiza imaginile existente?
{
  =[markdown] `docker image ls`
  ~[markdown] `docker image show`
  ~[markdown] `docker view`
  ~[markdown] `docker list`
}

::05k003:: [markdown] Cu ce comandă se poate șterge imaginea?
{
  =[markdown] `docker image rm`
  ~[markdown] `docker delete`
  ~[markdown] `docker remove`
  ~[markdown] `docker remove image`
}

::05k004:: [markdown] Cu ce comandă se poate crea un container?
{
  =[markdown] `docker container create`
  ~[markdown] `docker image build`
  ~[markdown] `docker container build`
  ~[markdown] `docker container start`
}

::05k005:: [markdown] Cu ce comandă se poate porni containerul existent?
{
  =[markdown] `docker container start`
  ~[markdown] `docker container run`
  ~[markdown] `docker container create`
  ~[markdown] `docker container build`
}

::05k006:: [markdown] Cu ce comandă se poate comunica cu containerul?
{
  =[markdown] `docker container exec`
  ~[markdown] `docker container run`
  ~[markdown] `docker container start`
  ~[markdown] `docker container stop`
}

::05k007:: [markdown] Cu ce comandă se poate reporni containerul?{
  =[markdown] `docker container restart`
  ~[markdown] `docker container start`
  ~[markdown] `docker container run`
  ~[markdown] `docker container stop`
}

::05k008:: [markdown] Cu ce comandă se poate copia fișierele în container?{
  =[markdown] `docker container cp`
  ~[markdown] `docker container mv`
  ~[markdown] `docker container copy`
  ~[markdown] `docker container move`
}

::05k009:: [markdown] Cu ce comandă se poate citi log-urile containerului?{
  =[markdown] `docker container logs`
  ~[markdown] `docker container show`
  ~[markdown] `docker container view`
  ~[markdown] `docker container list`
}

::05k010:: [markdown] Cu ce comandă se poate vizualiza lista containerelor?{
  =[markdown] `docker container ls`
  ~[markdown] `docker ls container`
  ~[markdown] `docker container view`
  ~[markdown] `docker image list`
}

::05k011:: [markdown] Cu ce comandă se poate opri containerul?{
  =[markdown] `docker container stop`
  ~[markdown] `docker stop container`
  ~[markdown] `docker container remove`
  ~[markdown] `docker container delete`
}

::05k012:: [markdown] Cu ce comandă se poate șterge containerul?{
  =[markdown] `docker container rm`
  ~[markdown] `docker remove container`
  ~[markdown] `docker container delete`
  ~[markdown] `docker container prune`
}

::05k013:: [markdown] Fie dat fișierul `Dockerfile.sample`. Cu ce comandă se poate construi imaginea cu numele `myimage`?
{
  =[markdown] `docker image build -t myimage -f Dockerfile.sample .`
  ~[markdown] `docker image build -t myimage Dockerfile.sample`
  ~[markdown] `docker image build --name myimage --file Dockerfile.sample .`
  ~[markdown] `docker build -f Dockerfile.sample -t myimage`
}

::05k014:: [markdown] Fie dată imaginea `myimage:1.0`. Cu ce comandă se poate crea containerul cu numele `mycontainer`?
{
  =[markdown] `docker container create --name mycontainer myimage:1.0`
  ~[markdown] `docker container create --name myimage:1.0 mycontainer`
  ~[markdown] `docker create --name mycontainer myimage .`
  ~[markdown] `docker build --name mycontainer myimage:1.0`
}

::05k015:: [markdown] Fie dat containerul `mycontainer`. Cu ce comandă se poate porni containerul în modul daemon?
{
  =[markdown] `docker start -d mycontainer`
  ~[markdown] `docker run -d mycontainer`
  ~[markdown] `docker run -d --name mycontainer`
  ~[markdown] `docker start -d --name mycontainer`
}

::05k016:: [markdown] Fie dat containerul pornit `mycontainer`. Cu ce comandă se poate conecta la container cu comanda `/bin/bash` pentru interacțiunea cu shell-ul?
{
  =[markdown] `docker exec -it mycontainer /bin/bash`
  ~[markdown] `docker run mycontainer /bin/bash`
  ~[markdown] `docker start mycontainer /bin/bash`
  ~[markdown] `docker container exec mycontainer /bin/bash`
}

::05k017:: [markdown] Fie dat containerul pornit `mycontainer`. Cu ce comandă se poate citi ultimile 50 linii din log-urile containerului?
{
  =[markdown] `docker logs -n 50 mycontainer`
  ~[markdown] `docker container logs -f 50 mycontainer`
  ~[markdown] `docker container show 50 mycontainer`
  ~[markdown] `docker logs -f 50 mycontainer`
}

::05k018:: [markdown] Fie dat containerul pornit `mycontainer`. Cu ce comandă se poate opri containerul?
{
  =[markdown] `docker container stop mycontainer`
  ~[markdown] `docker stop container mycontainer`
  ~[markdown] `docker container rm mycontainer`
  ~[markdown] `docker container delete mycontainer`
}

::05k019:: [markdown] FIe dată imaginea `myimage`. Cu ce comandă se poate porni containerul cu numele `mycontainer` și portul `8080` redirecționat la portul `80`?
{
  =[markdown] `docker container run -d --name mycontainer -p 8080:80 myimage`
  ~[markdown] `docker run -d --name mycontainer --ports 8080:80 myimage`
  ~[markdown] `docker container run --name mycontainer -p 8080 myimage`
  ~[markdown] `docker run -d --name mycontainer --expose 8080:80 myimage`
}

::05k020:: [markdown] Fie dat containerul pornit `mycontainer`. Cu ce comandă se poate copia fișierul `file.txt` în rădăcina containerului?
{
  =[markdown] `docker container cp file.txt mycontainer:/`
  ~[markdown] `docker image cp mycontainer:/file.txt .`
  ~[markdown] `docker cp mycontainer:/file.txt /`
  ~[markdown] `docker container write file.txt mycontainer:/file.txt`
}

$CATEGORY: examen/2_usage/05_docker_run

// Întrebări de tip _"răspuns scurt"_:

::05u001:: [markdown] Pentru a construi o imagine `myimage` din `Dockerfile`, trebuie să executați comanda {=docker build -t myimage . =docker build --tag myimage . }

::05u002:: [markdown] Pentru a construi o imagine `webserver` din `Dockerfile.nginx`, trebuie să executați comanda {= docker build -t webserver -f Dockerfile.nginx . =docker build -t webserver --file Dockerfile.nginx . =docker build --tag webserver -f Dockerfile.nginx . =docker build --tag webserver --file Dockerfile.nginx . =docker build --file Dockerfile.nginx --tag webserver . =docker build -f Dockerfile.nginx --tag webserver . =docker build --file Dockerfile.nginx -t webserver . =docker build -f Dockerfile.nginx -t webserver . }

::05u003:: [markdown] Pentru a construi o imagine `sample` cu eticheta `1.0` din `Dockerfile`, trebuie să executați comanda {= docker build -t sample\:1.0 . =docker build --tag sample\:1.0 . }

::05u004:: [markdown] Pentru a construi o imagine `sample` din `Dockerfile`, care se află în directorul `php-fpm`, trebuie să executați comanda {= docker build -t sample\:1.0 php-fpm =docker build --tag sample\:1.0 php-fpm =docker build -t sample\:1.0 ./php-fpm =docker build --tag sample\:1.0 ./php-fpm =docker build -t sample\:1.0 php-fpm/ =docker build --tag sample\:1.0 php-fpm/ =docker build -t sample\:1.0 ./php-fpm/ =docker build --tag sample\:1.0 ./php-fpm/ }

::05u005:: [markdown] Pentru vizualizarea listei de imagini existente, utilizați comanda {=docker images}

::05u006:: [markdown] Pentru a șterge imaginea `sample`, utilizați comanda {=docker rmi sample}

::05u007:: [markdown] Pentru a șterge imaginile `sample` și `webserver`, utilizați comanda {=docker rmi sample webserver =docker rmi webserver sample}

::05u008:: [markdown] Pentru a crea un container `mycontainer` pe baza imaginii `myimage`, utilizați comanda {=docker create --name mycontainer myimage}

::05u009:: [markdown] Pentru a porni containerul `mycontainer`, utilizați comanda {=docker start mycontainer}

::05u010:: [markdown] Pentru a crea un container pe baza imaginii `mariadb` și a-l porni imediat, utilizați comanda {=docker run mariadb}

::05u011:: [markdown] Pentru a crea un container pe baza imaginii `mariadb` cu numele `mydb` și a-l porni imediat, utilizați comanda {=docker run --name mydb mariadb}

::05u012:: [markdown] Pentru a crea un container pe baza imaginii `nginx` cu numele `web` și a-l porni imediat în fundal, utilizați comanda {=docker run --name web -d nginx =docker run -d --name web nginx}

::05u013:: [markdown] Vizualizarea listei de containere care rulează se poate face cu ajutorul comenzii {=docker ps}

::05u014:: [markdown] Vizualizarea listei de toate containerele se poate face cu ajutorul comenzii {=docker ps -a}

::05u015:: [markdown] Executarea comenzii `/etc/init.d/nginx reload` în containerul `nginx` care rulează se poate face cu ajutorul comenzii {=docker exec nginx /etc/init.d/nginx reload}

::05u016:: [markdown] Executarea comenzii `php /var/www/html/cli/cleancache.php` în containerul `php-fpm` care rulează se poate face cu ajutorul comenzii {=docker exec php-fpm php /var/www/html/cli/cleancache.php}

::05u017:: [markdown] Pentru a porni aplicatia `bash` în containerul `debian` care rulează cu modul interactiv activat, se utilizează comanda {=docker exec -it debian bash =docker exec -i -t debian bash =docker exec -t -i debian bash =docker exec -t -i debian bash =docker exec -ti debian bash}
  
::05u018:: [markdown] Pentru a opri containerul `mycontainer`, se utilizează comanda {=docker stop mycontainer}

::05u019:: [markdown] Pentru a șterge containerul `mycontainer`, se utilizează comanda {=docker rm mycontainer}

::05u020:: [markdown] Pentru a reporni containerul `mc`, se utilizează comanda {=docker restart mc}

::05u021:: [markdown] Pentru vizualizarea jurnalelor containerului `php-fpm`, se utilizează comanda {=docker logs php-fpm}

::05u022:: [markdown] Pentru vizualizarea jurnalelor containerului `web` în modul `follow`, se utilizează comanda {=docker logs -f mysql =docker logs --follow mysql}

::05u023:: [markdown] Pentru copierea fișierului `index.html` din containerul `web` din directorul `/var/www/html` în directorul local `./html`, se utilizează comanda {=docker cp web\:/var/www/html/index.html ./html =docker cp web\:/var/www/html/index.html ./html/ =docker cp web\:/var/www/html/index.html html/ =docker cp web\:/var/www/html/index.html html}

::05u024:: [markdown] Pentru copierea fișierului `index.html` din directorul local `./html` în directorul `/var/www/html` al containerului `web`, se utilizează comanda {=docker cp ./html/index.html web\:/var/www/html =docker cp ./html/index.html web\:/var/www/html/ =docker cp html/index.html web\:/var/www/html =docker cp html/index.html web\:/var/www/html/}
  
::05u025:: [markdown] În container în baza imaginii `myserver` poate fi pornită comanda `/bin/sh` cu ajutorul comenzii {=docker run -it myserver /bin/sh =docker run -i -t myserver /bin/sh =docker run -t -i myserver /bin/sh =docker run -ti myserver /bin/sh}

// # Întrebări la tema "Comenzile suplimentare ale Dockerfile"

$CATEGORY: examen/1_knowledge/06_dockerfile_ii

::06k001:: [markdown] Pentru specificarea unei variabile de mediu în imaginea containerului, se folosește directiva{
    =[markdown] `ENV`
    ~[markdown] `ARG`
    ~[markdown] `VAR`
    ~[markdown] `VARIABLE`
}

::06k002:: [markdown] Pentru specificarea argumentului de construcție, care poate fi folosit în timpul construirii imaginii, se folosește directiva
{
    =[markdown] `ARG`
    ~[markdown] `ENV`
    ~[markdown] `BUILD_ARG`
    ~[markdown] `VAR`
}

::06k003:: [markdown] Pentru a deschide un port al containerului, se folosește directiva
{
    =[markdown] `EXPOSE`
    ~[markdown] `PORT`
    ~[markdown] `OPEN`
    ~[markdown] `PUBLISH`
}

::06k004:: [markdown] Pentru specificarea punctului de montare al volumului în container, se folosește directiva
{
    =[markdown] `VOLUME`
    ~[markdown] `MOUNT`
    ~[markdown] `MOUNTPOINT`
    ~[markdown] `MOUNTVOLUME`
}

::06k005:: [markdown] Datele meta ale imaginii pot fi specificate cu ajutorul directivei
{
    =[markdown] `LABEL`
    ~[markdown] `META`
    ~[markdown] `METADATA`
    ~[markdown] `COMMENT`
}

::06k006:: [markdown] Schimbarea shell-ului implicit în imagine se poate face cu ajutorul directivei
{
    =[markdown] `SHELL`
    ~[markdown] `CMD`
    ~[markdown] `SH`
    ~[markdown] `BASH`
}

::06k007:: [markdown] Verificarea funcționării imaginii se poate face cu ajutorul directivei
{
    =[markdown] `HEALTHCHECK`
    ~[markdown] `CHECK`
    ~[markdown] `TEST`
    ~[markdown] `VERIFY`
}

::06k008:: [markdown] Argumentul de construcție `DEBIAN_VERSION` în Dockerfile se poate defini astfel
{
    =[markdown] `ARG DEBIAN_VERSION`
    ~[markdown] `ENV DEBIAN_VERSION`
    ~[markdown] `VAR DEBIAN_VERSION`
    ~[markdown] `SET DEBIAN_VERSION`
}

::06k009:: [markdown] Variabila de mediu `DEBIAN_VERSION` în Dockerfile se poate defini astfel
{
    =[markdown] `ENV DEBIAN_VERSION`
    ~[markdown] `ARG DEBIAN_VERSION`
    ~[markdown] `VAR DEBIAN_VERSION`
    ~[markdown] `SET DEBIAN_VERSION`
}

::06k010:: [markdown] Pentru a defini argumentul de construcție `DEBIAN_VERSION` cu valoarea `10` la construirea imaginii `myimage`, se folosește comanda
{
    =[markdown] `docker build --build-arg DEBIAN_VERSION=10 -t myimage .`
    ~[markdown] `docker build -e DEBIAN_VERSION=10 -t myimage .`
    ~[markdown] `docker build --arg DEBIAN_VERSION=10 -t myimage .`
    ~[markdown] `docker build --build-env DEBIAN_VERSION=10 -t myimage .`
}

//Вопросы типа _"короткий ответ"_:
$CATEGORY: examen/2_usage/06_dockerfile_ii

::06u001:: [markdown] Pentru a specifica argumentul de construcție `UBUNTU_VERSION` cu valoarea `20.04`, se adaugă în Dockerfile următoarea linie {=ARG UBUNTU_VERSION\=20.04}

::06u002:: [markdown] Pentru a specifica argumentul de construcție `APP_DIR` cu valoarea `/usr/src/app`, se adaugă în Dockerfile următoarea linie {=ARG APP_DIR\=/usr/src/app}

::06u003:: [markdown] Pentru a specifica variabila de mediu `APP_DIR` cu valoarea `/usr/src/app`, se adaugă în Dockerfile următoarea linie {=ENV APP_DIR\=/usr/src/app}

::06u004:: [markdown] Pentru a specifica variabila de mediu `UBUNTU_VERSION` cu valoarea `20.04`, se adaugă în Dockerfile următoarea linie {=ENV UBUNTU_VERSION\=20.04}

::06u005:: [markdown] Pentru a specifica argumentul de construcție `UBUNTU_VERSION` cu valoarea `20.04` la construirea imaginii `myimage`, se folosește comanda {=docker build --build-arg UBUNTU_VERSION\=20.04 -t myimage . =docker build -t myimage --build-arg UBUNTU_VERSION\=20.04 .}

::06u006:: [markdown] Pentru definirea argumentului de construcție `APP_DIR` cu valoarea `/usr/src/app` la construirea imaginii `myimage`, se folosește comanda {=docker build --build-arg APP_DIR\=/usr/src/app -t myimage . =docker build -t myimage --build-arg APP_DIR\=/usr/src/app .}

::06u007:: [markdown] Dockerfile este definită variabila de mediu `UBUNTU_VERSION`. Scrieți directiva care va afișa valoarea acestei variabile de mediu în timpul construirii imaginii în fișierul `/version.txt`. {=RUN echo $UBUNTU_VERSION > /version.txt =RUN echo "$UBUNTU_VERSION" > /version.txt =RUN echo $\{UBUNTU_VERSION\} > /version.txt}

::06u008:: [markdown] În fișier Dockerfile este definit argumentul de construcție `UBUNTU_VERSION`. Scrieți directiva care va defini variabila de mediu `UBUNTU_VERSION` cu valoarea argumentului de construcție.{=ENV UBUNTU_VERSION\=$UBUNTU_VERSION=ENV UBUNTU_VERSION\=$\{UBUNTU_VERSION\}=ENV UBUNTU_VERSION\="$UBUNTU_VERSION"}

::06u009:: [markdown] În Dockerfile este definit argumentul de construcție `UBUNTU_VERSION`. Scrieți directiva care va defini crearea imaginii pe baza imaginii `ubuntu` cu utilizarea argumentului de construcție `UBUNTU_VERSION`. {=FROM ubuntu\:$UBUNTU_VERSION=FROM ubuntu\:$\{UBUNTU_VERSION\}}

::06u010:: [markdown] Pentru a deschide portul `80` în container, se adaugă în Dockerfile următoarea linie{=EXPOSE 80}

::06u011:: [markdown] Pentru a deschide portul `8080` în container, se adaugă în Dockerfile următoarea linie{=EXPOSE 8080}

::06u012:: [markdown] Pentru a proba portul `80` al containerului pe portul `8080` al gazdei la crearea și pornirea containerului cu imaginea `myimage`, se folosește comanda{=docker run -p 8080\:80 myimage}

::06u013:: [markdown] Pentru a defini punctul de montare al volumului la directorul `/data` în container, se adaugă în Dockerfile următoarea linie{=VOLUME /data}

::06u014:: [markdown] Pentru a defini punctul de montare al volumului la directorul `/var/lib/mysql` în container, se adaugă în Dockerfile următoarea linie{=VOLUME /var/lib/mysql}

::06u015:: [markdown] Pentru a defini metadatele imaginii `maintainer` cu valoarea `Gicu Stirbu`, se adaugă în Dockerfile următoarea linie{=LABEL maintainer\="Gicu Stirbu"=LABEL maintainer\=Gicu Stirbu}

::06u016:: [markdown] Pentru a defini metadatele imaginii `version` cu valoarea `1.0`, se adaugă în Dockerfile următoarea linie{=LABEL version\="1.0"=LABEL version\=1.0}

// # Întrebări pentru "Interacțiunea containerelor"

$CATEGORY: examen/1_knowledge/07_container_usage

::07k001:: [markdown] Vizualizarea listei de volume existente se poate face cu ajutorul comenzii\:
{
   =[markdown]`docker volume ls`
   ~[markdown]`docker volume list`
   ~[markdown]`docker volume show`
   ~[markdown]`docker volume inspect`
}

::07k002:: [markdown] Pentru a crea un volum cu numele `opt` se folosește comanda\:
{
   =[markdown]`docker volume create opt`
   ~[markdown]`docker volume create --name opt`
   ~[markdown]`docker volume make opt`
   ~[markdown]`docker volume create name\=opt`
}

::07k003:: [markdown] Pentru a vizualiza informații despre volumul `opt` se folosește comanda\:
{
   =[markdown]`docker volume inspect opt`
   ~[markdown]`docker volume show opt`
   ~[markdown]`docker volume info opt`
   ~[markdown]`docker volume ls opt`
}

::07k004:: [markdown] Pentru a șterge volumul `opt` se folosește comanda\:
{
   =[markdown]`docker volume rm opt`
   ~[markdown]`docker volume erase opt`
   ~[markdown]`docker volume delete opt`
   ~[markdown]`docker volume prune opt`
}

::07k005:: [markdown] Pentru a șterge toate volumele neutilizate se poate folosi comanda\:
{
   =[markdown]`docker volume prune`
   ~[markdown]`docker volume remove`
   ~[markdown]`docker volume clear`
   ~[markdown]`docker volume rm`
}

::07k006:: [markdown] Vizualizarea listei de rețele se poate face cu ajutorul comenzii\:
{
   =[markdown]`docker network list`
   ~[markdown]`docker network view`
   ~[markdown]`docker network show`
   ~[markdown]`docker network inspect`
}

::07k007:: [markdown] Pentru a crea o rețea cu numele `local` se folosește comanda\:
{
   =[markdown]`docker network create local`
   ~[markdown]`docker network make --name local`
   ~[markdown]`docker network make local`
   ~[markdown]`docker network create name=local`
}

::07k008:: [markdown] Pentru a vizualiza informații despre rețeaua `local` se folosește comanda\:
{
   =[markdown]`docker network inspect local`
   ~[markdown]`docker network show local`
   ~[markdown]`docker network info local`
   ~[markdown]`docker network ls local`
}

::07k009:: [markdown] Pentru a șterge rețeaua `local` se folosește comanda\:
{
   =[markdown]`docker network rm local`
   ~[markdown]`docker network erase local`
   ~[markdown]`docker network delete local`
   ~[markdown]`docker network prune local`
}

::07k010:: [markdown] Pentru a conecta containerul `frontend` la rețeaua `local` se poate folosi comanda\:
{
   =[markdown]`docker network connect local frontend`
   ~[markdown]`docker network connect frontend local`
   ~[markdown]`docker network attach frontend local`
   ~[markdown]`docker network attach local frontend`
}

::07k011:: [markdown] Pentru a deconecta containerul `frontend` de la rețeaua `local` se poate folosi comanda\:
{
   =[markdown]`docker network disconnect local frontend`
   ~[markdown]`docker network disconnect frontend local`
   ~[markdown]`docker network detach frontend local`
   ~[markdown]`docker network detach local frontend`
}

::07k012:: [markdown] Pentru a șterge toate rețelele neutilizate se poate folosi comanda\:
{
   =[markdown]`docker network prune`
   ~[markdown]`docker network remove`
   ~[markdown]`docker network clear`
   ~[markdown]`docker network rm`
}

$CATEGORY: examen/2_usage/07_container_usage
// Întrebări de tip _răspuns scurt_:

::07u001:: [markdown] Pentru a crea containerul `webserver` pe baza imaginii `webserver` cu redirecționarea portului `80` containerului pe portul `8000` gazdei se folosește comanda\: {=docker create --name webserver -p 8000\:80 webserver =docker create --name webserver --port 8000\:80 webserver =docker create -p 8000\:80 --name webserver webserver =docker create --port 8000\:80 --name webserver webserver}

::07u002:: [markdown] Pentru a crea și rula containerul `webserver` pe baza imaginii `webserver` cu redirecționarea portului `80` containerului pe portul `8080` gazdei se folosește comanda\: {=docker run --name webserver -p 8080\:80 webserver =docker run -p 8080\:80 --name webserver webserver =docker run --name webserver --port 8080\:80 webserver =docker run --port 8080\:80 --name webserver webserver}

::07u003:: [markdown] Pentru a crea și rula containerul `webserver` pe baza imaginii `webserver` cu montarea volumului `opt` în directorul `/opt` al containerului se folosește comanda\: {=docker run -v opt\:/opt --name webserver webserver =docker run --volume opt\:/opt --name webserver webserver =docker run --name webserver -v opt\:/opt webserver =docker run --name webserver --volume opt\:/opt webserver}

::07u004:: [markdown] Pentru a crea și rula containerul `nodeapp` pe baza imaginii `nodeapp` cu montarea volumului `app` în directorul `/app` al containerului se folosește comanda\: {=docker run -v app\:/app --name nodeapp nodeapp =docker run --volume app\:/app --name nodeapp nodeapp =docker run --name nodeapp -v app\:/app nodeapp =docker run --name nodeapp --volume app\:/app nodeapp}

::07u005:: [markdown] Pentru a crea și rula containerul `webserver` pe baza imaginii `webserver` cu conectarea la rețeaua `local` se folosește comanda\: {= docker run --name webserver --network local webserver =docker run --network local --name webserver webserver}

::07u006:: [markdown] Pentru a crea și rula containerul `nodeapp` pe baza imaginii `nodeapp` cu conectarea la rețeaua `backend` se folosește comanda\: {=docker run --name nodeapp --network backend nodeapp =docker run --network backend --name nodeapp nodeapp}

::07u007:: [markdown] Pentru a șterge rețeaua `local` se folosește comanda\: {=docker network rm local}

::07u008:: [markdown] În Docker pentru a crea o rețea cu numele `local` se folosește comanda\: {=docker network create local}

::07u009:: [markdown] Pentru a adăuga containerul `frontend` la rețeaua `local` se folosește comanda\: {=docker network connect local frontend}

::07u010:: [markdown] În Docker pentru a crea un volum cu numele `opt` se folosește comanda\: {=docker volume create opt}

::07u011:: [markdown] Pentru a șterge volumul `opt` se folosește comanda\: {=docker volume rm opt}

// # Intrebari pe tema "Crearea unui cluster de containere cu ajutorul Docker Compose"

$CATEGORY:  examen/1_knowledge/08_docker_compose_i

::08k001:: [markdown] Docker Compose este
{
    = [markdown]instrument pentru descrierea și rularea aplicațiilor multi-container
    ~ [markdown]instrument pentru descrierea și rularea aplicațiilor single-container
    ~ [markdown]serviciu pentru gestionarea imaginilor containerelor
    ~ [markdown]serviciu pentru gestionarea containerelor
}

::08k002:: [markdown] Care format este utilizat pentru descrierea aplicațiilor multi-container în Docker Compose?
{
    = [markdown]YAML
    ~ [markdown]JSON
    ~ [markdown]XML
    ~ [markdown]TOML
}

::08k003:: [markdown] Cum se numește fișierul utilizat pentru descrierea aplicațiilor multi-container în Docker Compose?
{
    = [markdown]docker-compose.yml
    ~ [markdown]docker-compose.xml
    ~ [markdown]docker-compose.json
    ~ [markdown]docker-compose.toml
}

::08k004:: [markdown] Care comandă poate fi utilizată pentru a construi și rula aplicația multi-container descrisă în fișierul `docker-compose.yml`?
{
    = [markdown]`docker-compose up`
    ~ [markdown]`docker-compose start`
    ~ [markdown]`docker-compose run`
    ~ [markdown]`docker-compose exec`
}

::08k005:: [markdown] Care comandă poate fi utilizată pentru a opri și șterge aplicația multi-container pornită?
{
    = [markdown]`docker-compose down`
    ~ [markdown]`docker-compose stop`
    ~ [markdown]`docker-compose stop`
    ~ [markdown]`docker-compose rm`
}

::08k006:: [markdown] Pentru a construi aplicația multi-container descrisă în fișierul `docker-compose.yml`, trebuie să executați comanda
{
    = [markdown]`docker-compose build`
    ~ [markdown]`docker-compose compile`
    ~ [markdown]`docker-compose start`
    ~ [markdown]`docker-compose run`
}

::08k007:: [markdown] Este dat fișierul `docker-compose.yml`
    ```yaml
    services\:
      web\:
        image\: nginx\:latest
        ports\:
          - "8080\:80"
    ```
    Ce container va fi pornit la executarea comenzii `docker-compose up`?
{
    = [markdown]web
    ~ [markdown]nginx
    ~ [markdown]latest
    ~ [markdown]informație insuficientă pentru a răspunde
}

::08k008:: [markdown]În fișierul `docker-compose.yml` trebuie să specificați
{
    = [markdown]lista serviciilor
    ~ [markdown]lista imaginilor
    ~ [markdown]lista rețelelor
    ~ [markdown]lista volumelor
}

::08k009:: [markdown] Care cheie este utilizată pentru a specifica serviciile în fișierul `docker-compose.yml`?
{
    = [markdown]services
    ~ [markdown]containers
    ~ [markdown]service
    ~ [markdown]images
}

::08k010:: [markdown]Care cheie este utilizată pentru a specifica imaginea pe baza căreia va fi creat containerul în fișierul `docker-compose.yml`?
{
    = [markdown]image
    ~ [markdown]container
    ~ [markdown]service
    ~ [markdown]images
}

::08k011:: [markdown] Dacă cheia `image` nu este specificată pentru un serviciu, trebuie să specificați cheia
{
    = [markdown]build
    ~ [markdown]create
    ~ [markdown]run
    ~ [markdown]from
}

::08k012:: [markdown]Care cheie este utilizată pentru a specifica porturile care trebuie expuse din container în sistemul gazdă în fișierul `docker-compose.yml`?
{
    = [markdown]ports
    ~ [markdown]expose
    ~ [markdown]publish
    ~ [markdown]forward
}

::08k013:: [markdown] Pentru a specifica montarea unui volum în container în fișierul `docker-compose.yml` se utilizează cheia
{
    = [markdown]volumes
    ~ [markdown]mounts
    ~ [markdown]bind
    ~ [markdown]attach
}

::08k014:: [markdown] Pentru a specifica rețelele utilizate de un serviciu în fișierul `docker-compose.yml` se utilizează cheia
{
    = [markdown]networks
    ~ [markdown]net
    ~ [markdown]network
    ~ [markdown]nets
}

::08k015:: [markdown] Pentru a specifica ordinea de pornire a serviciilor în fișierul `docker-compose.yml` se utilizează cheia
{
    = [markdown]depends_on
    ~ [markdown]run_after
    ~ [markdown]after
    ~ [markdown]before
}

::08k016:: [markdown] Pentru a vizualiza jurnalul de evenimente al serviciului `myservice`, descris în fișierul `docker-compose.yml`, trebuie să executați comanda
{
    = [markdown]`docker-compose logs myservice`
    ~ [markdown]`docker-compose log myservice`
    ~ [markdown]`docker-compose journal myservice`
    ~ [markdown]`docker-compose events myservice`
}

::08k017:: [markdown] Pentru a executa comanda `command` în interiorul containerului serviciului `myservice`, descris în fișierul `docker-compose.yml`, trebuie să executați comanda
{
    = [markdown]`docker-compose exec myservice command`
    ~ [markdown]`docker-compose run myservice command`
    ~ [markdown]`docker-compose start myservice command`
    ~ [markdown]`docker-compose stop myservice command`
}

$CATEGORY:  examen/2_usage/08_docker_compose_i
// ## Raspuns scurt

::08u001:: [markdown] Pentru a specifica versiunea sintaxei Docker Compose în fișierul `docker-compose.yml` se utilizează cheia {=version}

::08u002:: [markdown] Pentru a specifica serviciile în fișierul `docker-compose.yml` se utilizează cheia {=services}

::08u003:: [markdown] Pentru a specifica imaginea pe baza căreia va fi creat containerul, în fișierul `docker-compose.yml` se utilizează cheia {=image}

::08u004:: [markdown] Pentru a specifica porturile care trebuie expuse din container în sistemul gazdă, în fișierul `docker-compose.yml` se utilizează cheia {=ports}

::08u005:: [markdown] Pentru a specifica montarea unui volum în container, în fișierul `docker-compose.yml` se utilizează cheia {=volumes}

::08u006:: [markdown] Pentru a specifica rețelele utilizate de un serviciu, în fișierul `docker-compose.yml` se utilizează cheia {=networks}

::08u007:: [markdown] Pentru a specifica ordinea de pornire a serviciilor, în fișierul `docker-compose.yml` se utilizează cheia {=depends_on}

::08u008:: [markdown] Pentru a specifica calea către directorul cu fișierul `Dockerfile`, în fișierul `docker-compose.yml` se utilizează cheia {=build}

::08u009:: [markdown] Pentru a specifica comanda care va fi executată la pornirea containerului, în fișierul `docker-compose.yml` se utilizează cheia {=command}

::08u010:: [markdown] Pentru a crea infrastructura definită în fișierul `docker-compose.yml` și a construi containerele serviciilor, trebuie să executați comanda {=docker-compose build =docker compose build}

::08u011:: [markdown] Pentru a porni containerele serviciilor definite în fișierul `docker-compose.yml`, trebuie să executați comanda {=docker-compose up =docker-compose up -d =docker compose up =docker compose up -d}

::08u012:: [markdown] Pentru a opri și șterge containerele serviciilor definite în fișierul `docker-compose.yml`, trebuie să executați comanda {=docker-compose down =docker compose down}

::08u013:: [markdown] Pentru a vizualiza jurnalul de evenimente al serviciului `myservice`, definit în fișierul `docker-compose.yml`, trebuie să executați comanda {=docker-compose logs myservice =docker compose logs myservice =docker-compose logs -f myservice =docker compose logs -f myservice}

::08u014:: [markdown] Pentru a executa comanda `command` în interiorul containerului serviciului `myservice`, definit în fișierul `docker-compose.yml`, trebuie să executați comanda {=docker-compose exec myservice command =docker compose exec myservice command}

// # Întrebări pentru lecția "Caracteristicile configurării clusterului de containere"

$CATEGORY:  examen/1_knowledge/09_docker_compose_ii

::09k001:: [markdown]Care cheie este utilizată în fișierul `docker-compose.yml` pentru a specifica variabilele de mediu care trebuie transmise containerului?
{
    = [markdown]environment
    ~ [markdown]env
    ~ [markdown]variables
    ~ [markdown]vars
}

::09k002:: [markdown]Care cheie este utilizată în fișierul `docker-compose.yml` pentru a specifica fișierul cu variabile de mediu?
{
    = [markdown]env_file
    ~ [markdown]environment_file
    ~ [markdown]variables_file
    ~ [markdown]vars_file
}

::09k003:: [markdown]Care fișier este automat inclus de Docker Compose în fișierul `docker-compose.yml`, dacă variabilele de mediu sunt declarate în el?
{
    = [markdown].env
    ~ [markdown].vars
    ~ [markdown].variables
    ~ [markdown].env_file
}

::09k004:: [markdown]Care cheie este utilizată în fișierul `docker-compose.yml` pentru a specifica argumentele de construire a imaginii?
{
    = [markdown]build.args
    ~ [markdown]image.args
    ~ [markdown]build.arguments
    ~ [markdown]image.variables
}

::09k005:: [markdown]Care cheie este utilizată în fișierul `docker-compose.yml` pentru a specifica contextul de construire a imaginii?
{
    = [markdown]build.context
    ~ [markdown]image.context
    ~ [markdown]build.dir
    ~ [markdown]image.dir
}

::09k006:: [markdown]Cum se poate limita timpul de procesare disponibil containerului în `docker-compose.yml`?
{
    = [markdown]specificând valoarea cheii `deploy.resources.limits.cpus`
    ~ [markdown]specificând valoarea cheii `deploy.resources.cpu_limit`
    ~ [markdown]specificând valoarea cheii `deploy.resources.cpu.quota`
    ~ [markdown]specificând valoarea cheii `deploy.resources.cpu.shares`
}

::09k007:: [markdown]Cum se poate limita memoria disponibilă containerului în `docker-compose.yml`?
{
    = [markdown]specificând valoarea cheii `deploy.resources.limits.memory`
    ~ [markdown]specificând valoarea cheii `deploy.resources.memory_limit`
    ~ [markdown]specificând valoarea cheii `deploy.resources.memory.quota`
    ~ [markdown]specificând valoarea cheii `deploy.resources.memory.shares`
}

::09k008:: [markdown]Care cheie este utilizată în fișierul `docker-compose.yml` pentru a specifica limitele de resurse ale containerului?
{
    = [markdown]deploy.resources
    ~ [markdown]resources
    ~ [markdown]limits
    ~ [markdown]deploy.limits
}

// # Întrebări pe tema "Integrare și livrare continuă (CI/CD)"
// ## Întrebări cu un singur răspuns corect din patru opțiuni

$CATEGORY:  examen/1_knowledge/10_CI_CD

::10k001:: [markdown]Practica de dezvoltare software în care dezvoltatorii își integrează modificările în ramura principală de mai multe ori pe zi se numește
{
    = [markdown]Integrare continuă
    ~ [markdown]Livrare continuă
    ~ [markdown]Implementare continuă
    ~ [markdown]Testare continuă
}

::10k002:: [markdown]Build-urile programate ale produsului permit
{
   = [markdown]reducerea încărcării pe serverul de integrare continuă
   ~ [markdown]reducerea timpului de testare
   ~ [markdown]reducerea timpului de livrare
   ~ [markdown]reducerea timpului de implementare
}

::10k003:: [markdown]Practica de dezvoltare software în care fiecare modificare a codului trece prin teste automatizate pentru a respecta standardele de calitate și securitate și este gata pentru lansare în producție se numește
{
    = [markdown]Livrare continuă
    ~ [markdown]Implementare continuă
    ~ [markdown]Integrare continuă
    ~ [markdown]Testare continuă
}

::10k004:: [markdown]Practica de dezvoltare software în care fiecare modificare a codului, care trece cu succes toate etapele de testare, este implementată automat pe serverul de producție se numește
{
    = [markdown]Implementare continuă
    ~ [markdown]Livrare continuă
    ~ [markdown]Integrare continuă
    ~ [markdown]Testare continuă
}

::10k005:: [markdown]Pentru a implementa integrarea continuă este necesar
{
    = [markdown]să se utilizeze un sistem de control al versiunilor
    ~ [markdown]să se utilizeze un sistem de management al proiectelor
    ~ [markdown]să se utilizeze un sistem de management al sarcinilor
    ~ [markdown]să se utilizeze un sistem de management al lansărilor
}

::10k006:: [markdown]În cadrul integrării continue, modificările codului pot fi integrate în ramura principală
{
    = [markdown]de mai multe ori pe zi
    ~ [markdown]o dată pe săptămână
    ~ [markdown]de fiecare dată când se implementează o nouă funcționalitate
    ~ [markdown]de fiecare dată când are loc o lansare
}

::10k007:: [markdown]În dezvoltarea unui produs software pentru implementarea unei noi funcționalități
{
    = [markdown]trebuie creată o nouă ramură pe baza ramurii principale
    ~ [markdown]toate modificările sunt realizate în ramura principală
    ~ [markdown]nu este posibil să se lucreze simultan în mai multe ramuri
    ~ [markdown]trebuie creată o nouă ramură pe baza ramurii de testare
}

::10k008:: [markdown]În cadrul integrării continue este necesar
{
    = [markdown]să se utilizeze un sistem de control al versiunilor
    ~ [markdown]să se utilizeze un sistem de management al proiectelor
    ~ [markdown]să se utilizeze un sistem de management al sarcinilor
    ~ [markdown]să se utilizeze un sistem de management al lansărilor
}

::10k009:: [markdown]În cadrul integrării continue, fuziunea modificărilor în ramura principală are loc
{
    = [markdown]după trecerea cu succes a tuturor testelor
    ~ [markdown]la fiecare modificare a codului
    ~ [markdown]la fiecare commit
    ~ [markdown]la fiecare lansare
}

::10k010:: [markdown]Integrarea continuă permite
{
    = [markdown]identificarea și remedierea erorilor în stadiile incipiente ale dezvoltării
    ~ [markdown]reducerea timpului de testare
    ~ [markdown]reducerea timpului de livrare
    ~ [markdown]reducerea timpului de implementare
}

::10k011:: [markdown]Care dintre următoarele instrumente este utilizat pentru organizarea proceselor CI/CD?
{
    = [markdown]Jenkins
    ~ [markdown]JIRA
    ~ [markdown]Confluence
    ~ [markdown]Git
}

::10k012:: [markdown]Care dintre următoarele reprezintă o caracteristică cheie a livrării continue?
{
    = [markdown]Fiecare modificare a codului trece prin teste automatizate și este gata pentru lansare în producție
    ~ [markdown]Fiecare modificare a codului este automat implementată în mediul de producție
    ~ [markdown]Modificările codului sunt integrate în ramura principală de mai multe ori pe zi
    ~ [markdown]Reducerea timpului de execuție a testelor
}

// # Întrebări pe tema "Optimizarea imaginii containerului"

$CATEGORY: examen/1_knowledge/11_image_optimization

::11k001:: [markdown]Care comanda permite vizualizarea listei de imagini de container?
{
   = [markdown]`docker images`
   ~ [markdown]`docker ps`
   ~ [markdown]`docker container ls`
   ~ [markdown]`docker inspect`
}

::11k002:: [markdown]Care comandă permite vizualizarea informațiilor despre straturile imaginii?
{
   = [markdown]`docker history`
   ~ [markdown]`docker inspect`
   ~ [markdown]`docker image ls`
   ~ [markdown]`docker image inspect`
}

::11k003:: [markdown]Este dat Dockerfile
   ```dockerfile
   FROM nginx\:latest
   COPY ./site /usr/share/nginx/html
   ```
   Cum se poate reduce dimensiunea imaginii rezultate?
{
   = [markdown]înlocuiți `nginx\:latest` cu `nginx\:alpine`
   ~ [markdown]utilizați construcția multi-stage
   ~ [markdown]reduceți numărul de straturi
   ~ [markdown]utilizați `.dockerignore`
}

::11k004:: [markdown]Este dat Dockerfile
   ```dockerfile
   FROM nginx\:alpine
   COPY ./site /usr/share/nginx/html
   ```
   Cum se poate reduce dimensiunea imaginii rezultate?
{
   = [markdown]păstrați site-ul într-un volum montat
   ~ [markdown]utilizați construcția multi-stage
   ~ [markdown]reduceți numărul de straturi
   ~ [markdown]utilizați `.dockerignore`
}

::11k005:: [markdown]Este dat Dockerfile
   ```dockerfile
   FROM debian\:bookworm-slim
   RUN apt-get update && apt-get install -y php-cli
   RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
   ```
   Cum se poate reduce dimensiunea imaginii rezultate?
{
   = [markdown]combinați straturile
   ~ [markdown]utilizați construcția multi-stage
   ~ [markdown]păstrați datele într-un volum montat
   ~ [markdown]utilizați `.dockerignore`
}

::11k006:: [markdown]Este dat Dockerfile
   ```dockerfile
   FROM gcc\:latest
   COPY app.cpp .
   RUN g++ app.cpp -o app -static
   CMD ["./app"]
   ```
   Cum se poate reduce dimensiunea imaginii rezultate?
{
   = [markdown]utilizați construcția multi-stage
   ~ [markdown]reduceți numărul de straturi
   ~ [markdown]păstrați datele într-un volum montat
   ~ [markdown]utilizați `.dockerignore`
}

::11k007:: [markdown] Având Dockerfile-ul\:
   ```dockerfile
   FROM php\:8.1
   COPY ./site /var/www/html
   ```
   Cum putem reduce dimensiunea imaginii rezultate?
{
   = [markdown]înlocuim `php\:8.1` cu `php\:8.1-alpine`
   ~ [markdown]folosim construcție multi-etapă
   ~ [markdown]reducem numărul de straturi
   ~ [markdown]folosim `.dockerignore`
}

::11k008:: [markdown] Având Dockerfile-ul\:
   ```dockerfile
   FROM drupal\:alpine
   COPY ./site /var/www/html
   ```
   Cum putem reduce dimensiunea imaginii rezultate?
{
   = [markdown]stocăm site-ul într-un volum montat
   ~ [markdown]folosim construcție multi-etapă
   ~ [markdown]reducem numărul de straturi
   ~ [markdown]folosim `.dockerignore`
}

::11k009:: [markdown] Având Dockerfile-ul\:
    ```dockerfile
    FROM ubuntu\:22.04
    RUN apt-get update && apt-get install -y python
    RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
    ```
    Cum putem reduce dimensiunea imaginii rezultate?
{
    = [markdown]combinăm straturile
    ~ [markdown]folosim construcție multi-etapă
    ~ [markdown]stocăm datele într-un volum montat
    ~ [markdown]folosim `.dockerignore`
}

::11k010:: [markdown] Având Dockerfile-ul\:
    ```dockerfile
    FROM openjdk\:latest
    COPY /app /
    RUN mvn install
    CMD ["java", "-cp", "app:app/lib/*"]
    ```
    Cum putem reduce dimensiunea imaginii rezultate?
{
    = [markdown]folosim construcție multi-etapă
    ~ [markdown]reducem numărul de straturi
    ~ [markdown]stocăm datele într-un volum montat
    ~ [markdown]folosim `.dockerignore`
}
